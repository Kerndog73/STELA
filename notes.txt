An interface defines the interface of a generic type. A generic function says
"I accept types that implement this interface" so whenever you try to call a
function with a type, the compiler will check if the type satisfies the
interface. The compiler will also check if the function uses the interface
correctly. This might be easier to implement than C++ style generics.

interface Ordered {
  func lt(Self) -> bool;
};

func min<T: Ordered>(vals: [T]) -> T {
  if (size(vals) == 0u) {
    return make T {};
  }
  var elem = vals[0];
  for (i := 1u; i != size(vals); i++) {
    if (val[i].lt(elem)) {
      elem = val[i];
    }
  }
  return elem;
}

func swap<T>(a: inout T, b inout T) {
  let temp = a;
  a = b;
  b = temp;
}

In provide functions for working with arrays, we're going to need some kind
of generics.

func duplicate<T>(arr: [T]) -> [T];
func capacity<T>(arr: [T]) -> uint;
func size<T>(arr: [T]) -> uint;
func push_back<T>(arr: inout [T], elem: T);
func append<T>(arr: inout [T], other: [T]);
func pop_back<T>(arr: inout [T]);
func resize<T>(arr: inout [T], size: uint);
func reserve<T>(arr: inout [T], size: uint);

The alternative is something like this:

if (funcName == "duplicate") {
  checkArgs(dupParams, args);
  return dupRet;
} else if ...

Is an if-else somewhere really that bad? Just for a few builtin functions.
It's a hell of a lot easier than implementing generics.

If I go to all the trouble of implementing generics then I might as well expose
some syntax for users.

We don't need generic types (only generic functions) to deal with arrays.

--------------------------------------------------------------------------------

A closure is a pointer to a function and a reference counted pointer to captured
variables.

struct Closure {
  Function *func;
  retain_ptr<Data> data;
};

The reference counted pointer makes the closure a reference type.

A closure behaves very similarly to an entt::delegate except that the a pointer
to captured variables is stored instead of an instance pointer.

A different wrapper function is used depending on whether data needs to be
captured. A non-capturing lambda yields the same closure as a regular function.

entt::delegate required wrapper functions but this implementation will not
require them.

Every function is actually a member function. So called "non-member functions"
accept a "this pointer" but simply ignore it. This means that a regular function
can be stored in a closure and it will ignore the nullptr to the captured data.
A capturing lambda function will accept the pointer to the captured data and
use it.

A closure is implemented in the same way that dynamic go-style interfaces
would be implemented except that the closure holds a single function pointer
where an interface would store a pointer to a table of function pointers that
make up the implementation of the interface. If we have one, do we really need
the other?

