A type trait checks for functions that are defined for a particular type.
A Hashable trait might be implemented like this:

trait Hashable<T> {
  func hash(cref T) -> uint;
};

This says that a type T is Hashable if there exists a hash function that takes
a cref to T and returns an uint.

We could allow for binary traits this

trait SwappableWith<T, U> {
  func swap(ref T, ref U);
};

I'm not sure if there is any use for binary traits.

Traits can be composed. You might want your hashable type to be comparable.

trait Hashable<T> {
  func hash(cref T) -> uint;
  trait EqualityComparable;
};

Maybe you want a function to find the index of an element in a hash table
You might do something like this:

func hashIndex<Key: Hashable>(key: cref Key, size: uint) {
  return hash(key) % size;
}

You cannot pass this function an object that doesn't have the Hashable trait.
This function only knows that the key is Hashable so it cannot assume that
the type has any other traits. For example,

func hashIndexInt<Key: Integral>(key: Key, size: uint) {
  return (make uint key) % size;
}
func hashIndex<Key: Hashable>(key: cref Key, size: uint) {
  // this is invalid even if hashIndex is called with an integer
  return hashIndexUint(key, size);
}

The traits required by hashIndexInt would have to be a subset of Hashable for
this to work. Using traits instead of the C++ way templates work (duck typing)
means that a generic function doesn't need to be type checked every time it is
instantiated.

You could use a function to tag a type and detect the function in the trait.

type T struct {};

func myCoolTag(T) {}

trait HasCoolTag<T> {
  func myCoolTag(T);
};

These tags could be used to describe a type. Since the functions are never,
actually called, they will be omitted from the executable.

Need some way of associating a type with another type.

type A struct {
  first: sint;
};
type B struct {
  first: real;
};

type FirstType<type A> = sint;
type FirstType<type B> = real;

Template specialization. This needs to be a part of traits somehow.
We need some way of referencing the associated type in the trait.
How do Rust and Swift do this?

Maybe...

assoc type FirstType{A} = sint;
assoc type FirstType{B} = real;

assoc let FirstTypeName{A} = "sint";
assoc let FirstTypeName{B} = "real";

trait HasFirst{T} {
  type FirstType{T};
  let FirstTypeName{T};
};

func getFirstName{T: HasFirst}() {
  // access associated let
  return FirstTypeName{T};
}

// access associated type in parametized type alias
type FT{T: HasFirst} = FirstType{T};

Maybe have a look at one of the Go generics proposals

--------------------------------------------------------------------------------

An interface defines the interface of a generic type. A generic function says
"I accept types that implement this interface" so whenever you try to call a
function with a type, the compiler will check if the type satisfies the
interface. The compiler will also check if the function uses the interface
correctly. This might be easier to implement than C++ style generics.

interface Ordered {
  func lt(Self) -> bool;
};

func min<T: Ordered>(vals: [T]) -> T {
  if (size(vals) == 0u) {
    return make T {};
  }
  var elem = vals[0];
  for (i := 1u; i != size(vals); i++) {
    if (val[i].lt(elem)) {
      elem = val[i];
    }
  }
  return elem;
}

func swap<T>(a: ref T, b ref T) {
  let temp = a;
  a = b;
  b = temp;
}

In provide functions for working with arrays, we're going to need some kind
of generics.

func capacity<T>(arr: [T]) -> uint;
func size<T>(arr: [T]) -> uint;
func push_back<T>(arr: ref [T], elem: T);
func append<T>(arr: ref [T], other: [T]);
func pop_back<T>(arr: ref [T]);
func resize<T>(arr: ref [T], size: uint);
func reserve<T>(arr: ref [T], size: uint);

We don't need generic types (only generic functions) to deal with arrays.

--------------------------------------------------------------------------------

A closure is a pointer to a function and a reference counted pointer to captured
variables.

struct Closure {
  Function *func;
  retain_ptr<Data> data;
};

The reference counted pointer makes the closure a reference type.

A closure behaves very similarly to an entt::delegate except that the a pointer
to captured variables is stored instead of an instance pointer.

entt::delegate required wrapper functions but this implementation will not
require them.

Every function is actually a member function. So called "non-member functions"
accept a "this pointer" but simply ignore it. This means that a regular function
can be stored in a closure and it will ignore the nullptr to the captured data.
A capturing lambda function will accept the pointer to the captured data and
use it.

A closure is implemented in the same way that dynamic go-style interfaces
would be implemented except that the closure holds a single function pointer
where an interface would store a pointer to a table of function pointers that
make up the implementation of the interface. If we have one, do we really need
the other?

--------------------------------------------------------------------------------

think about the rules for function overloading and shadowing. Overload across modules?
should mutability be part of the type system properly? What we have now just lets use make variables constant
deal with user types void *
functional switch
use google test and maybe google benchmark
cache some stuff in the AST. Benchmark
consider using ORC
help optimizer with switch on global let
trivially relocatable optimizations

This is could be part of the standard library
func (self: sint) to_string() -> [char]








USE A STELA SCRIPT TO DEFINE A VECTOR SPRITE








organize the src directory (folder references instead of groups)
use memcmp when possible
optimize for trivially copyable structs that fit in registers
treat the return parameter as an lvalue (NRVO)
move construct closure captures when possible
maybe ast::Type uniquing?
maybe we shouldn't inline so aggressively
swap operator? :=:
expose reference counted pointers
arrays should be value types
cref
  maybe cref could be a little smarter than const &
  for generic programming, it would be really handy if cref sint just passed
  sint by value.
  cref can bind to an rvalue like it can in C++

separate function signature from functions, lambdas and function types
  there are a lot of functions that only need to know the function signature
  but actually take sym::FuncParams or ast::Func.
  This is a mess!
consistent naming
  left -> lhs
  right -> rhs
  Type -> Ty
  member function -> method
  member variable -> field

is ptr_union a good idea?
  we can remove a few dynamic casts
  malloc returns a pointer with alignment of std::max_align_t

range for loops might speed up iteration


IDE extensions
  pretty printing
  syntax highlighing
  separate the two
  intellisense
  
Have a look at Wren and Crystal
