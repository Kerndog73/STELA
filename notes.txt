What would you use the blank identifier _ for?

Unused function parameters. Maybe you're conforming to an interface and
you need a parameter to satisfy the interface but you don't need to use it.

--------------------------------------------------------------------------------

An interface defines the interface of a generic type. A generic function says
"I accept types that implement this interface" so whenever you try to call a
function with a type, the compiler will check if the type satisfies the
interface. The compiler will also check if the function uses the interface
correctly. This might be easier to implement than C++ style generics.

--------------------------------------------------------------------------------

A closure is a pointer to a function and a reference counted pointer to captured
variables.

struct Closure {
  Function *func;
  retain_ptr<Data> data;
};

The reference counted pointer makes the closure a reference type.

A closure behaves very similarly to an entt::delegate except that the a pointer
to captured variables is stored instead of an instance pointer.

A different wrapper function is used depending on whether data needs to be
captured. A non-capturing lambda yields the same closure as a regular function.

entt::delegate required wrapper functions but this implementation will not
require them.

Every function is actually a member function. So called "non-member functions"
accept a "this pointer" but simply ignore it. This means that a regular function
can be stored in a closure and it will ignore the nullptr to the captured data.
A capturing lambda function will accept the pointer to the captured data and
use it.

A closure is implemented in the same way that dynamic go-style interfaces
would be implemented except that the closure holds a single function pointer
where an interface would store a pointer to a table of function pointers that
make up the implementation of the interface. If we have one, do we really need
the other?

--------------------------------------------------------------------------------

Since closures are reference types, it makes sense for interfaces to be
reference types as well. Interfaces hold a reference counted smart pointer to an
object.

--------------------------------------------------------------------------------

Everything is zero initialized by default. A reference type should be
initialized to null. Builtin types and references types can be contextually
converted to bool. If there are used in a context that expects a bool, they will
return a bool that denotes whether the object is alive or null.

--------------------------------------------------------------------------------

struct Slice {
  Array backing_array; // Reference counted pointer to array
  size_t capacity;     // Size of the backing array
  size_t begin;        // Beginning of the region on the backing array
  size_t end;          // End of the region on the backing array
};

Arrays are value types. Assigning an array makes a copy of the array.

Slices are reference types. Assigning a slice assigns a reference to an array.
This is because the slice stores a reference counted pointer to the backing
array. Creating a reference counted pointer to an array might be dangerous if
the array is stack allocated so arrays must be heap allocated. This means that
an array is just a pointer and the size of the array would be known in the type.

Need to extend subscript syntax to support slices. array[5:9]

I'd like to remove the `inout` keyword so instead of references, we should use
reference types. Slices are reference types. Arrays are value types.

--------------------------------------------------------------------------------

There are a lot of similarities between lambdas and functions. Try to minimize
the duplication of code. Maybe implement one in terms of the other or something
like that. Or implement them both in terms of a more low level concept.

--------------------------------------------------------------------------------

Do we really need to allow functions to be nested. Is it really necessary?
All you're doing is hiding the function. The nested function doesn't gain the
scope of the outer function. It's not a closure. It's just an anonymous
funciton. Disallowing nested functions will simplify a lot of the ExprLookup
code.
