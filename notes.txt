An interface defines the interface of a generic type. A generic function says
"I accept types that implement this interface" so whenever you try to call a
function with a type, the compiler will check if the type satisfies the
interface. The compiler will also check if the function uses the interface
correctly. This might be easier to implement than C++ style generics.

interface Ordered {
  func lt(Self) -> bool;
};

func min<T: Ordered>(vals: [T]) -> T {
  if (size(vals) == 0u) {
    return make T {};
  }
  var elem = vals[0];
  for (i := 1u; i != size(vals); i++) {
    if (val[i].lt(elem)) {
      elem = val[i];
    }
  }
  return elem;
}

func swap<T>(a: ref T, b ref T) {
  let temp = a;
  a = b;
  b = temp;
}

In provide functions for working with arrays, we're going to need some kind
of generics.

func capacity<T>(arr: [T]) -> uint;
func size<T>(arr: [T]) -> uint;
func push_back<T>(arr: ref [T], elem: T);
func append<T>(arr: ref [T], other: [T]);
func pop_back<T>(arr: ref [T]);
func resize<T>(arr: ref [T], size: uint);
func reserve<T>(arr: ref [T], size: uint);

We don't need generic types (only generic functions) to deal with arrays.

--------------------------------------------------------------------------------

A closure is a pointer to a function and a reference counted pointer to captured
variables.

struct Closure {
  Function *func;
  retain_ptr<Data> data;
};

The reference counted pointer makes the closure a reference type.

A closure behaves very similarly to an entt::delegate except that the a pointer
to captured variables is stored instead of an instance pointer.

entt::delegate required wrapper functions but this implementation will not
require them.

Every function is actually a member function. So called "non-member functions"
accept a "this pointer" but simply ignore it. This means that a regular function
can be stored in a closure and it will ignore the nullptr to the captured data.
A capturing lambda function will accept the pointer to the captured data and
use it.

A closure is implemented in the same way that dynamic go-style interfaces
would be implemented except that the closure holds a single function pointer
where an interface would store a pointer to a table of function pointers that
make up the implementation of the interface. If we have one, do we really need
the other?

--------------------------------------------------------------------------------

think about the rules for function overloading and shadowing. Overload across modules?
might need to rename builtin functions to make them less ambiguous. Maybe prefix with arr_
manually manage reference count
manually instantiate builtin functions
pointers instead of references
remove the null parameters from non-member functions that aren't used in pointers
should mutability be part of the type system properly? What we have now just lets use make variables constant
maybe a move keyword that does a similar job to std::move
remove the power operator **
deal with user types void *


find_package(LLVM REQUIRED CONFIG)
message(STATUS "Found LLVM ${LLVM_PACKAGE_VERSION}")

target_include_directories(STELA
        PUBLIC
        ${LLVM_INCLUDE_DIRS}
)

llvm_map_components_to_libnames(llvm_libs engine)

target_link_libraries(STELA
        PUBLIC
        ${llvm_libs}
)





I'm using cmake to compile a static library and an executable. The static library links to LLVM and the executable links to the static library. There is a test coverage build where some compiler flags are set. This is the difference between a regular build and a test coverage build:

if(TEST_COVERAGE)
        set(CMAKE_CXX_FLAGS "-DNDEBUG -DTEST_COVERAGE -O0 --coverage -fno-inline -fno-inline-small-functions -fno-default-inline")
endif()

The regular build is able to successfully link to LLVM and run a test. However, in the coverage build, the executable fails to link with this message:

undefined reference to `__gcov_exit'

Linking the coverage build with LLVM causes the undefined reference error. This is the difference:

target_link_libraries(STELA
        PUBLIC
        LLVMCore
)

Linking the static library with one of the LLVM components causes the test executable to fail with an undefined reference error. I don't understand how linking something can cause an unrelated symbol to be not found.
