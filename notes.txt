An interface defines the interface of a generic type. A generic function says
"I accept types that implement this interface" so whenever you try to call a
function with a type, the compiler will check if the type satisfies the
interface. The compiler will also check if the function uses the interface
correctly. This might be easier to implement than C++ style generics.

interface Ordered {
  func lt(Self) -> bool;
};

func min<T: Ordered>(vals: [T]) -> T {
  if (size(vals) == 0u) {
    return make T {};
  }
  var elem = vals[0];
  for (i := 1u; i != size(vals); i++) {
    if (val[i].lt(elem)) {
      elem = val[i];
    }
  }
  return elem;
}

func swap<T>(a: ref T, b ref T) {
  let temp = a;
  a = b;
  b = temp;
}

In provide functions for working with arrays, we're going to need some kind
of generics.

func capacity<T>(arr: [T]) -> uint;
func size<T>(arr: [T]) -> uint;
func push_back<T>(arr: ref [T], elem: T);
func append<T>(arr: ref [T], other: [T]);
func pop_back<T>(arr: ref [T]);
func resize<T>(arr: ref [T], size: uint);
func reserve<T>(arr: ref [T], size: uint);

We don't need generic types (only generic functions) to deal with arrays.

--------------------------------------------------------------------------------

A closure is a pointer to a function and a reference counted pointer to captured
variables.

struct Closure {
  Function *func;
  retain_ptr<Data> data;
};

The reference counted pointer makes the closure a reference type.

A closure behaves very similarly to an entt::delegate except that the a pointer
to captured variables is stored instead of an instance pointer.

entt::delegate required wrapper functions but this implementation will not
require them.

Every function is actually a member function. So called "non-member functions"
accept a "this pointer" but simply ignore it. This means that a regular function
can be stored in a closure and it will ignore the nullptr to the captured data.
A capturing lambda function will accept the pointer to the captured data and
use it.

A closure is implemented in the same way that dynamic go-style interfaces
would be implemented except that the closure holds a single function pointer
where an interface would store a pointer to a table of function pointers that
make up the implementation of the interface. If we have one, do we really need
the other?

--------------------------------------------------------------------------------

think about the rules for function overloading and shadowing. Overload across modules?
manually manage reference count
manually instantiate builtin functions
should mutability be part of the type system properly? What we have now just lets use make variables constant
maybe a move keyword that does a similar job to std::move
remove the power operator **
deal with user types void *
functional switch
clean up () in switch
use google test and maybe google benchmark
maybe remove () from a few places
cache some stuff in the AST. Benchmark
consider using ORC
maybe make semicolons optional
help optimizer with switch on global let
annotate AST with calls to ctor, dtor, etc
trivially relocatable optimizations

newArraySize is constant so this is just nullptr
newArraySize is always a constant!!!
OK to delete ArrayStorage when dat == nullptr as long as len == 0

if (newArraySize == 0) {
  return nullptr;
} else {
  return malloc(newArraySize * sizeof(Elem));
}

This is could be part of the standard library
func (self: sint) to_string() -> [char]

Do we really need to call copy constructors when passing arrays to functions?
Find a scenario where not calling the constructor would be a problem

Lifetimes begin in declarations in blocks
Lifetimes end at the end of blocks
continue, break and return end the lifetimes of objects in multiple blocks

Each block should have a list of objects that are created in that block
These objects must be destroyed when control exits that block
This list will be used to generate code for breaks, returns and continues

A stack of lists of elements
Creating a new block pushes onto the stack
Creating a new variable pushes onto the list at the top of the stack

statement at the end of non-terminated blocks?
inserted by the check missing return thing

destroy before branching
store stack index in jump statements
for loops have multiple scopes
don't pop from the stack when destroying. Iterate
pop from the stack when changing scope







USE A STELA SCRIPT TO DEFINE A VECTOR SPRITE
